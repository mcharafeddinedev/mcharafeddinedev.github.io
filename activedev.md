---
title: Current Pursuits
nav_exclude: true
---

# Current Pursuits

As I near the completion of my A.A.S. in Digital Gaming & Simulation (for Programmers)—a mostly generalist program covering programming, technical art, design, and production workflows—my focus has shifted toward building deeper technical depth as a gameplay programmer and software engineer. While my education provided a broad foundation across disciplines, my priority now is hands-on development: writing systems, refining architecture, improving workflows, and strengthening my fluency in code.

---

## Most Recent/Active Work

### Gameplay Systems & Prototyping

Currently developing an **endless-runner style arcade game** focused on responsive movement, state-driven mechanics, scoring systems, and replayable game loops. The project serves as a controlled environment for refining gameplay logic, modular systems, and moment-to-moment feel without unnecessary complexity.

### Engine-Level Exploration (C++)

Experimenting with creating a **custom 2D engine in C++**. While not yet production-ready, this work has strengthened my understanding of rendering fundamentals, entity management, and low-level architecture. I plan to revisit and expand this project as my C++ proficiency continues to grow.

### Tooling & Modern Workflows

While my primary focus is gameplay programming, I take a strong interest in lower-level computer science—how engines are structured, how systems interact, and how graphics are rendered. I actively explore **editor tooling and development automation**, including Python-based workflows for Unreal Engine tasks, data handling, and internal utilities.

---

## Learning Track

I use **guided, project-based courses** as deliberate practice—reinforcing fundamentals while applying them directly to real builds. When a project reaches polish or produces a viable executable, it moves to [Projects](projects.md).

### Current & Planned Study

These Udemy courses support my ongoing learning in C++, C#, gameplay programming, and in-engine workflows:

**Unreal Engine & C++**
- **Unreal Engine 5 C++ Game Development** — Gameplay systems, AI behavior, C++/Blueprint integration, and modern UE5 workflows
- **C++ Fundamentals: Game Programming For Beginners** — Core C++ with Raylib, building 2D games from scratch, memory management, and game loop architecture
- **Learn C++ for Game Development** — Language foundations, structured labs, and practical application to real-time systems
- **Learn C++ and Make a Game from Scratch** — Low-level engine concepts, custom rendering, and building without frameworks
- **Learn C++ Programming By Making Games** — Project-based C++ through interactive game builds, reinforcing OOP and data structures
- **Learn C++ Programming By Making Games Volume 2** — Advanced patterns, more complex systems, and deeper architectural practice

**Unity & C#**
- **Complete C# Unity 3D Game Development in Unity 6** — Full 3D game development pipeline, C# scripting, physics, AI, UI systems, and publishing workflows
- **Unity 2D Game: Kawaii Survivor** — Roguelike architecture, procedural systems, stat management, and polished 2D gameplay loops


---

## Player Perspective & QA

Beyond programming, I also bring a **deep player perspective** shaped by over 25 years of gaming experience across platforms, genres, and eras. I've played competitively, analyzed mechanics, glitches, exploits, and easter eggs across countless titles, and developed an intuition for **game feel and balance**—what makes movement satisfying, when systems or mechanics feel fair or unfair, and how small adjustments can dramatically change player experience.

This background directly informs my work:

- **Playtesting** — I test my own builds rigorously, with iterative adjustments, catching edge cases and feel issues before they compound
- **Game Feel** — As a player, I've developed a sense for when mechanics feel "off"—whether it's input lag, movement weight, damage numbers, or progression pacing
- **Player Connection** — I always think like a player first, which helps me anticipate friction points and balance concerns
- **Documentation** — I'm well practiced in clear, organized reporting—useful for bug tracking, design specs, and team communication

I see QA as a specialized discipline that complements programming and game design. My A.A.S. has given me a generalist foundation—touching programming, art pipelines, design, and technical workflows. That broad exposure, combined with my extensive playtesting experience, helps me understand what QA teams look for: edge cases, balance issues, and player friction points. This perspective makes me a better developer and helps me communicate more effectively with team members, both personally and in documentation.

---

## Long-Term Direction

My goal is to keep learning and growing as a **gameplay programmer with strong systems and technical foundations**, to build core features & mechanics and work across engines, codebases, and tools while maintaining a player-first design mindset.

That means continuing to:

- Build clean, scalable gameplay systems
- Go deeper on C++ and engine internals
- Stay sharp on evolving tools and practices
- Playtest early, iterate often, and take feedback seriously

---

[← Projects](projects.md) · [← Home](index.md)
